{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"grib-getter","text":"<p>Bandwidth-optimized GRIB weather data fetcher for NOAA GFS forecasts.</p> <p>Designed for bandwidth-limited environments (like sailboat liveaboards) with intelligent download management and automatic data integrity protection.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Smart Download Management: Checks for existing files before downloading</li> <li>Bandwidth Optimization: <code>--new-only</code>, <code>--force</code>, and <code>--check-only</code> modes</li> <li>Automatic Backups: Creates <code>.bak</code> files before overwriting to prevent data loss</li> <li>Interactive CLI: Built with Typer for excellent user experience</li> <li>Configurable Storage: Set custom storage paths for GRIB files</li> <li>First-Run Setup: Automatic configuration on first use</li> <li>Extensible: Add new forecast models by dropping TOML files in <code>settings/</code></li> </ul>"},{"location":"#use-case","title":"Use Case","text":"<p>Perfect for sailors, cruisers, and off-grid users who need:</p> <ul> <li>Reliable weather data with minimal bandwidth usage</li> <li>Protection against corrupted downloads in unreliable connectivity</li> <li>Easy-to-use command-line interface</li> <li>Flexible configuration for different use cases</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation - Get started in minutes</li> <li>Quick Start - Basic usage examples</li> <li>Configuration - Customize for your needs</li> <li>Architecture - How it works</li> <li>API Reference - Detailed documentation</li> </ul>"},{"location":"#technology-stack","title":"Technology Stack","text":"<p>Built with modern Python tools:</p> <ul> <li>Python 3.13+ - Latest Python features</li> <li>Typer - Beautiful CLI with Rich integration</li> <li>Pydantic - Data validation with type hints</li> <li>Dynaconf - Flexible settings management</li> <li>httpx - Modern HTTP client</li> <li>loguru - Simple, powerful logging</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - See LICENSE file for details.</p>"},{"location":"#author","title":"Author","text":"<p>Johnny (@johnny111272)</p>"},{"location":"adding_models/","title":"Adding New Models","text":"<p>grib-getter is designed for easy extensibility. Add new forecast models by creating a TOML file - no code changes required!</p>"},{"location":"adding_models/#quick-start","title":"Quick Start","text":"<p>To add a new model (e.g., NAM):</p> <ol> <li>Create <code>settings/nam.toml</code></li> <li>Copy structure from <code>settings/gfs.toml</code></li> <li>Update with NAM-specific config</li> <li>Done! Auto-discovered and loaded</li> </ol>"},{"location":"adding_models/#model-configuration-structure","title":"Model Configuration Structure","text":"<p>Each model TOML file has four sections:</p>"},{"location":"adding_models/#1-model_data-available-options","title":"1. <code>[{model}_data]</code> - Available Options","text":"<p>Lists all variables and levels the model provides:</p> <pre><code>[nam_data]\nvariables = [\n    \"TMP\",      # Temperature\n    \"UGRD\",     # U-component of wind\n    \"VGRD\",     # V-component of wind\n    \"PRMSL\",    # Pressure reduced to MSL\n    # ... full list\n]\nlevels = [\n    \"surface\",\n    \"2_m_above_ground\",\n    \"10_m_above_ground\",\n    \"1000_mb\",\n    # ... full list\n]\n</code></pre>"},{"location":"adding_models/#2-model_queries-query-presets","title":"2. <code>[{model}_queries]</code> - Query Presets","text":"<p>Named presets for common use cases:</p> <pre><code>[nam_queries.sailing_basic]\nvariables = \"0x204000014400110280\"  # Hex bitmask\nlevels = \"0x18000000000000001000000\"  # Hex bitmask\n\n[nam_queries.aviation_complete]\nvariables = \"0xFFFFFFFFFFFFFFFFFF\"\nlevels = \"0xFFFFFFFFFFFFFFFFFF\"\n</code></pre> <p>Bitmask Encoding: Each bit position corresponds to a variable/level:</p> <pre><code>Position:  0    1    2    3    4    ...\nVariable:  TMP  UGRD VGRD PRES HGHT ...\nMask:      1    1    0    1    0    ...\n           \u2191    \u2191    \u2191    \u2191    \u2191\n         Include these, skip VGRD and HGHT\n</code></pre> <p>Convert binary to hex: <code>0b11010... = 0x1A...</code></p>"},{"location":"adding_models/#3-model_products-download-products","title":"3. <code>[{model}_products]</code> - Download Products","text":"<p>Different resolution/processing variants:</p> <pre><code>[nam_products.nam_12km]\nname = \"nam_12km\"\nfilter = \"filter_nam_12.pl\"\nfile = \"nam.t{cycle_hour_utc}z.awphys{forecast_hour}.tm00.grib2\"\ndir = \"/nam.{date_utc}\"\n\n[nam_products.nam_32km]\nname = \"nam_32km\"\nfilter = \"filter_nam_32.pl\"\nfile = \"nam.t{cycle_hour_utc}z.awphys{forecast_hour}.tm00.grib2\"\ndir = \"/nam.{date_utc}\"\n</code></pre>"},{"location":"adding_models/#4-model_settings-model-specific-settings-optional","title":"4. <code>[{model}_settings]</code> - Model-Specific Settings (Optional)","text":"<p>Additional model-specific configuration:</p> <pre><code>[nam_settings]\nforecast_interval_hours = 3  # NAM runs every 3 hours\nmax_forecast_hours = 84      # NAM provides 84-hour forecasts\n</code></pre>"},{"location":"adding_models/#complete-example-adding-nam","title":"Complete Example: Adding NAM","text":"<p>File: <code>settings/nam.toml</code></p> <pre><code>[nam_products.nam_12km]\nname = \"nam_12km\"\nfilter = \"filter_nam_12.pl\"\nfile = \"nam.t{cycle_hour_utc}z.awphys00.tm00.grib2\"\ndir = \"/nam.{date_utc}\"\n\n[nam_queries.sailing_basic]\nvariables = \"0x204000014400110280\"\nlevels = \"0x18000000000000001000000\"\n\n[nam_queries.conus_weather]\nvariables = \"0x3FFFFFFFFFFFFF\"\nlevels = \"0x1FFFFFFFFFFFF\"\n\n[nam_data]\nvariables = [\n    \"TMP\",\n    \"UGRD\",\n    \"VGRD\",\n    \"PRMSL\",\n    \"APCP\",\n    \"TCDC\",\n    \"RH\",\n    \"DPT\",\n    # ... add all NAM variables\n]\nlevels = [\n    \"surface\",\n    \"2_m_above_ground\",\n    \"10_m_above_ground\",\n    \"850_mb\",\n    \"700_mb\",\n    \"500_mb\",\n    # ... add all NAM levels\n]\n\n[nam_settings]\nforecast_interval_hours = 3\nmax_forecast_hours = 84\n</code></pre>"},{"location":"adding_models/#cli-integration","title":"CLI Integration","text":"<p>After creating the TOML file, the model is automatically available but not yet integrated into the CLI menu.</p> <p>Future CLI Update (manual code change required):</p> <pre><code># In fetch_forecast.py - when multi-model selection is added\navailable_models = list(settings.keys())  # Auto-discovers NAM\n</code></pre> <p>For now, update the CLI to reference the new model explicitly:</p> <pre><code># Change hardcoded \"GFS\" references to support NAM\nmodel_name = settings.defaults.model_name  # Could be NAM\n</code></pre>"},{"location":"adding_models/#testing-new-model","title":"Testing New Model","text":"<p>Test the configuration loads correctly:</p> <pre><code>from config import settings\n\n# Check NAM data loaded\nprint(hasattr(settings, 'NAM_DATA'))  # Should be True\nprint(len(settings.NAM_DATA.variables))\n\n# Check NAM queries loaded\nprint('sailing_basic' in settings.NAM_QUERIES)\n\n# Check NAM products loaded\nprint(hasattr(settings.NAM_PRODUCTS, 'nam_12km'))\n</code></pre>"},{"location":"adding_models/#finding-model-information","title":"Finding Model Information","text":""},{"location":"adding_models/#noaa-documentation","title":"NOAA Documentation","text":"<ul> <li>NOMADS Data Access</li> <li>GRIB Filter Scripts</li> <li>Model-specific pages (e.g., NAM, HRRR, RAP)</li> </ul>"},{"location":"adding_models/#inspecting-existing-grib-filters","title":"Inspecting Existing GRIB Filters","text":"<p>Visit NOAA's filter pages to see available variables and levels:</p> <pre><code>https://nomads.ncep.noaa.gov/cgi-bin/filter_nam.pl\n</code></pre> <p>Check the HTML source for the complete list.</p>"},{"location":"adding_models/#testing-urls","title":"Testing URLs","text":"<p>Manually construct and test URLs:</p> <pre><code>curl \"https://nomads.ncep.noaa.gov/cgi-bin/filter_nam.pl?dir=/nam.20251106&amp;file=nam.t12z.awphys00.tm00.grib2&amp;var_TMP=on&amp;lev_surface=on&amp;subregion=&amp;toplat=50&amp;leftlon=-100&amp;rightlon=-80&amp;bottomlat=40\"\n</code></pre>"},{"location":"adding_models/#common-patterns","title":"Common Patterns","text":""},{"location":"adding_models/#high-resolution-regional-models","title":"High-Resolution Regional Models","text":"<p>Models like NAM, HRRR, RAP:</p> <ul> <li>Smaller geographic areas</li> <li>Higher resolution</li> <li>More frequent updates</li> <li>Shorter forecast horizons</li> </ul> <pre><code>[hrrr_settings]\nforecast_interval_hours = 1  # Hourly updates\nmax_forecast_hours = 18      # 18-hour forecasts\n</code></pre>"},{"location":"adding_models/#global-models","title":"Global Models","text":"<p>Models like GFS, ECMWF:</p> <ul> <li>Global coverage</li> <li>Lower resolution</li> <li>Longer forecast horizons</li> <li>Less frequent updates</li> </ul> <pre><code>[gfs_settings]\nforecast_interval_hours = 6   # Every 6 hours\nmax_forecast_hours = 384      # 16-day forecasts\n</code></pre>"},{"location":"adding_models/#bitmask-generation","title":"Bitmask Generation","text":""},{"location":"adding_models/#manual-method","title":"Manual Method","text":"<ol> <li>List all variables in order</li> <li>Mark which ones to include (1) or exclude (0)</li> <li>Convert binary string to hex</li> </ol> <pre><code>variables = [\"TMP\", \"UGRD\", \"VGRD\", \"PRES\", \"RH\"]\nselected = [True, True, False, True, False]\nbinary = \"11010\"  # LSB first\nhex_mask = hex(int(binary, 2))  # \"0x1a\"\n</code></pre>"},{"location":"adding_models/#using-helper-function","title":"Using Helper Function","text":"<pre><code>from noaa_query_builder import build_new_mask\n\nall_vars = [\"TMP\", \"UGRD\", \"VGRD\", \"PRES\", \"RH\"]\nselected_vars = (\"TMP\", \"UGRD\", \"PRES\")\nmask = build_new_mask(all_vars, selected_vars)\nprint(mask)  # \"0x1a\"\n</code></pre>"},{"location":"adding_models/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Learn about config system</li> <li>Architecture - Understand how it works</li> <li>API Reference - Query builder functions</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>grib-getter is designed around three core principles:</p> <ol> <li>Bandwidth Optimization - Minimize downloads in limited connectivity</li> <li>Data Integrity - Protect against corrupted downloads</li> <li>Extensibility - Easy to add new models via configuration</li> </ol>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<pre><code>User Input (CLI)\n    \u2193\nConfiguration Loading (dynaconf)\n    \u2193\nQuery URL Generation (noaa_query_builder.py)\n    \u2193\nHTTP Fetching with Retry (noaa_grib_fetcher.py)\n    \u2193\nGRIB2 File (grib_data/YYYYMMDD_HH_model_preset/)\n</code></pre>"},{"location":"architecture/#component-architecture","title":"Component Architecture","text":""},{"location":"architecture/#cli-layer-fetch_forecastpy","title":"CLI Layer (<code>fetch_forecast.py</code>)","text":"<p>Responsibilities: - User interaction (Typer + Rich) - First-run configuration - Bandwidth control flags (<code>--new-only</code>, <code>--force</code>, <code>--check-only</code>) - Backup file management</p> <p>Key Features: - Interactive prompts with sensible defaults - Non-interactive mode for automation - Logging with rich handler (loguru + rich)</p>"},{"location":"architecture/#query-builder-noaa_query_builderpy","title":"Query Builder (<code>noaa_query_builder.py</code>)","text":"<p>Responsibilities: - Convert user input to NOAA API URLs - Forecast time calculations (with lookback) - Geographic bounding box calculations - Variable/level selection via hexadecimal bitmasks</p> <p>Key Concepts:</p> <p>Bitmask Selection: Variables and levels are selected using hexadecimal bitmasks for efficient encoding:</p> <pre><code># All available variables\nvariables = [\"TMP\", \"UGRD\", \"VGRD\", \"PRMSL\", ...]\n\n# Hex mask: which ones to include?\nhex_mask = \"0x204000014400110280\"\n\n# Decoded to binary, selects specific variables\n# Bit 1 = include, Bit 0 = exclude\n</code></pre> <p>Forecast Time Lookback: Most recent forecasts aren't immediately available on NOAA servers (processing delay). The query builder generates multiple candidate times:</p> <pre><code># Try: 18Z, 12Z, 06Z (today)\n# Looking back up to max_lookback_hours\n</code></pre>"},{"location":"architecture/#fetcher-noaa_grib_fetcherpy","title":"Fetcher (<code>noaa_grib_fetcher.py</code>)","text":"<p>Responsibilities: - HTTP requests with retry logic - Exponential backoff on failures - NOAA rate limiting (10s between requests) - Comprehensive attempt tracking</p> <p>Retry Strategy:</p> <pre><code>For each forecast time (newest to oldest):\n    For each attempt (up to max_attempts):\n        Try to fetch\n        If 404: Try next (older) forecast time\n        If 5xx: Retry same URL with backoff\n        If success: Done!\n</code></pre> <p>Rate Limiting: NOAA requires 10 seconds between requests. The fetcher automatically handles this:</p> <pre><code>if not first_url:\n    time.sleep(settings.noaa_settings.rate_limit_seconds)\n</code></pre>"},{"location":"architecture/#configuration-configpy","title":"Configuration (<code>config.py</code>)","text":"<p>Responsibilities: - Load and merge configuration files - Auto-discover model configs in <code>settings/</code> - Provide type-safe access to settings</p> <p>Configuration Merging:</p> <pre><code>settings = Dynaconf(\n    settings_files=[\n        \"settings.toml\",      # Defaults\n        \"user.toml\",          # User overrides\n        \".secrets.toml\",      # Secrets\n        \"settings/*.toml\",    # Auto-discovered models\n    ],\n    merge_enabled=True,  # Merge [core_settings] across files\n)\n</code></pre>"},{"location":"architecture/#file-organization","title":"File Organization","text":""},{"location":"architecture/#run-specific-folders","title":"Run-Specific Folders","text":"<p>Files are organized by forecast run:</p> <pre><code>grib_data/\n\u2514\u2500\u2500 20251106_18_GFS_sailing_basic/\n    \u251c\u2500\u2500 20251106_18_000_GFS_sailing_basic.grib  (analysis)\n    \u251c\u2500\u2500 20251106_18_001_GFS_sailing_basic.grib  (1-hour forecast)\n    \u251c\u2500\u2500 20251106_18_006_GFS_sailing_basic.grib  (6-hour forecast)\n    \u2514\u2500\u2500 ...\n</code></pre> <p>Benefits: - Easy to identify complete vs partial downloads - Natural sorting by forecast hour - Supports future batch downloading - Atomic operations (all files from same run)</p>"},{"location":"architecture/#backup-protection","title":"Backup Protection","text":"<p>When overwriting existing files:</p> <pre><code>20251106_18_000_GFS_sailing_basic.grib      (current)\n20251106_18_000_GFS_sailing_basic.grib.00.bak\n20251106_18_000_GFS_sailing_basic.grib.01.bak\n...\n</code></pre> <p>Why: In unreliable connectivity, a corrupted download shouldn't destroy good data from earlier successful downloads.</p>"},{"location":"architecture/#configuration-system","title":"Configuration System","text":""},{"location":"architecture/#layered-configuration","title":"Layered Configuration","text":"<pre><code>settings.toml          (shipped defaults)\n    \u2193 merged with\nuser.toml              (user preferences)\n    \u2193 merged with\n.secrets.toml          (API keys)\n    \u2193 merged with\nsettings/gfs.toml      (GFS model config)\n    \u2193 merged with\nsettings/nam.toml      (NAM model config - auto-discovered)\n    \u2193\nFinal Settings Object\n</code></pre>"},{"location":"architecture/#auto-discovery","title":"Auto-Discovery","text":"<p>Glob pattern <code>settings/*.toml</code> enables zero-code-change extensibility:</p> <pre><code># Add NAM model\n$ cp settings/gfs.toml settings/nam.toml\n# Edit nam.toml with NAM-specific config\n# That's it! Automatically loaded\n</code></pre>"},{"location":"architecture/#data-validation","title":"Data Validation","text":"<p>All configuration and data structures use Pydantic for validation:</p> <pre><code>class CoreSettings(pydantic.BaseModel, frozen=True):\n    grib_url: str\n    output_dir: pathlib.Path\n    forecast_interval_hours: int\n    max_lookback_hours: int\n</code></pre> <p>Benefits: - Type safety throughout - Early error detection - Self-documenting via type hints - Auto-generated from docstrings (this documentation!)</p>"},{"location":"architecture/#future-extensions","title":"Future Extensions","text":""},{"location":"architecture/#async-batch-downloading-planned","title":"Async Batch Downloading (Planned)","text":"<p>Current structure supports future async batch downloads:</p> <ol> <li>Download analysis file (000) to confirm run exists</li> <li>Launch async downloads for all forecast hours</li> <li>All saved to same run-specific folder</li> </ol> <p>File naming already supports this: - <code>YYYYMMDD_HH_000_model_preset.grib</code> (analysis) - <code>YYYYMMDD_HH_FFF_model_preset.grib</code> (forecasts)</p>"},{"location":"architecture/#design-patterns","title":"Design Patterns","text":""},{"location":"architecture/#functional-core-imperative-shell","title":"Functional Core, Imperative Shell","text":"<ul> <li>Core: Pure functions for calculations (geographic, time, masking)</li> <li>Shell: I/O operations (HTTP, file writes, user interaction)</li> </ul>"},{"location":"architecture/#configuration-driven","title":"Configuration-Driven","text":"<ul> <li>New models: add TOML file</li> <li>New query presets: edit model TOML</li> <li>No code changes required for common extensions</li> </ul>"},{"location":"architecture/#type-safe-throughout","title":"Type-Safe Throughout","text":"<ul> <li>Pydantic models for validation</li> <li>Extensive type annotations</li> <li>basedpyright for static checking</li> </ul>"},{"location":"architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Adding Models - Add new forecast models</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>grib-getter uses a layered configuration system powered by Dynaconf.</p>"},{"location":"configuration/#configuration-files","title":"Configuration Files","text":""},{"location":"configuration/#settingstoml-application-defaults","title":"<code>settings.toml</code> (Application Defaults)","text":"<p>Version-controlled defaults that ship with the application:</p> <pre><code>[core_settings]\ngrib_url = \"https://nomads.ncep.noaa.gov/cgi-bin/{filter}\"\nforecast_interval_hours = 6\nmax_lookback_hours = 18\n\n[http_settings]\nsuccess = 200\nnot_found = 404\nserver_error = 500\nrequest_timeout_seconds = 30\n\n[noaa_settings]\nrate_limit_seconds = 10\n\n[retry_settings]\nmax_attempts = 3\ninitial_delay_seconds = 5\nmax_delay_seconds = 300\ntimeout_minutes = 30\n\n[default_location]\ncenter_lat = 45.0\ncenter_lon = -93.0\nheight_degrees = 90.0\nwidth_degrees = 180.0\n\n[defaults]\ngrib_dir = \"grib_data\"\nmodel_name = \"GFS\"\nproduct_name = \"gfs_quarter_degree\"\n\n[backup]\nmax_count = 100\nextension = \".bak\"\n\n[query]\nvar_prefix = \"var_\"\nlev_prefix = \"lev_\"\n</code></pre>"},{"location":"configuration/#usertoml-user-preferences","title":"<code>user.toml</code> (User Preferences)","text":"<p>User-specific configuration (gitignored, auto-created):</p> <pre><code>[core_settings]\noutput_dir = \"/Users/johnny/weather/grib_data\"\n</code></pre>"},{"location":"configuration/#settingstoml-model-configs","title":"<code>settings/*.toml</code> (Model Configs)","text":"<p>Model-specific configurations are auto-discovered from the <code>settings/</code> directory.</p> <p>Current models: - <code>settings/gfs.toml</code> - Global Forecast System</p> <p>Future models: Add a new file and it's automatically loaded! - <code>settings/nam.toml</code> - North American Mesoscale - <code>settings/hrrr.toml</code> - High-Resolution Rapid Refresh</p>"},{"location":"configuration/#configuration-priority","title":"Configuration Priority","text":"<p>Settings are loaded in order (later files override earlier):</p> <ol> <li><code>settings.toml</code> - Application defaults</li> <li><code>user.toml</code> - User overrides</li> <li><code>.secrets.toml</code> - Secrets (if present)</li> <li><code>settings/*.toml</code> - Model configs (auto-discovered)</li> <li>Environment variables - <code>DYNACONF_*</code> prefix</li> </ol> <p>Example: <pre><code># Override output_dir via environment variable\nexport DYNACONF_CORE_SETTINGS__OUTPUT_DIR=/tmp/grib_data\npython fetch_forecast.py fetch -p sailing_basic\n</code></pre></p>"},{"location":"configuration/#storage-configuration","title":"Storage Configuration","text":""},{"location":"configuration/#via-cli","title":"Via CLI","text":"<pre><code># Interactive\npython fetch_forecast.py configure\n\n# Direct\npython fetch_forecast.py configure --storage /path/to/grib_data\n</code></pre>"},{"location":"configuration/#via-file","title":"Via File","text":"<p>Edit <code>user.toml</code>:</p> <pre><code>[core_settings]\noutput_dir = \"/path/to/grib_data\"\n</code></pre>"},{"location":"configuration/#via-environment","title":"Via Environment","text":"<pre><code>export DYNACONF_CORE_SETTINGS__OUTPUT_DIR=/path/to/grib_data\n</code></pre>"},{"location":"configuration/#location-defaults","title":"Location Defaults","text":"<p>Change default location in <code>user.toml</code>:</p> <pre><code>[default_location]\ncenter_lat = 37.7749  # San Francisco\ncenter_lon = -122.4194\nheight_degrees = 60.0\nwidth_degrees = 120.0\n</code></pre>"},{"location":"configuration/#retry-settings","title":"Retry Settings","text":"<p>Adjust retry behavior in <code>user.toml</code>:</p> <pre><code>[retry_settings]\nmax_attempts = 5  # More retries for unreliable connections\ninitial_delay_seconds = 10\nmax_delay_seconds = 600\ntimeout_minutes = 60\n</code></pre>"},{"location":"configuration/#http-settings","title":"HTTP Settings","text":"<p>Customize timeouts:</p> <pre><code>[http_settings]\nrequest_timeout_seconds = 60  # Longer timeout for slow connections\n</code></pre>"},{"location":"configuration/#backup-settings","title":"Backup Settings","text":"<p>Control backup behavior:</p> <pre><code>[backup]\nmax_count = 50  # Fewer backups to save space\nextension = \".backup\"  # Different extension\n</code></pre>"},{"location":"configuration/#model-configuration","title":"Model Configuration","text":"<p>See Adding Models for details on adding new forecast models.</p>"},{"location":"configuration/#configuration-validation","title":"Configuration Validation","text":"<p>Settings are validated using Pydantic models, ensuring type safety and catching errors early.</p> <p>If you have an invalid configuration:</p> <pre><code>ValidationError: 1 validation error for CoreSettings\nforecast_interval_hours\n  Input should be a valid integer [type=int_type, input_value='six', input_type=str]\n</code></pre>"},{"location":"configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture - How configuration system works</li> <li>Adding Models - Extend with new models</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.13 or higher</li> <li>Internet connection for downloading forecasts</li> </ul>"},{"location":"installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<pre><code># Clone the repository\ngit clone https://github.com/johnny111272/grib-getter.git\ncd grib-getter\n\n# Install with uv\nuv sync\n</code></pre>"},{"location":"installation/#using-pip","title":"Using pip","text":"<pre><code># Clone the repository\ngit clone https://github.com/johnny111272/grib-getter.git\ncd grib-getter\n\n# Install with pip\npip install -e .\n</code></pre>"},{"location":"installation/#first-time-configuration","title":"First-Time Configuration","text":"<p>On first run, grib-getter will prompt you to configure the storage directory:</p> <pre><code>python fetch_forecast.py fetch\n</code></pre> <p>You'll be asked:</p> <ol> <li>Storage directory - Where to save GRIB files (default: <code>./grib_data</code>)</li> <li>Directory creation (if it doesn't exist)</li> </ol> <p>This creates a <code>user.toml</code> file with your preferences.</p>"},{"location":"installation/#manual-configuration","title":"Manual Configuration","text":"<p>You can also configure storage directly:</p> <pre><code>python fetch_forecast.py configure --storage ~/weather/grib_data\n</code></pre> <p>Or edit <code>user.toml</code> manually:</p> <pre><code>[core_settings]\noutput_dir = \"/path/to/your/grib_data\"\n</code></pre>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>Check that everything works:</p> <pre><code>python fetch_forecast.py list-presets\n</code></pre> <p>You should see:</p> <pre><code>Available Query Presets:\n\n  \u2022 sailing_basic\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Learn basic usage</li> <li>Configuration - Customize settings</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"quickstart/#interactive-mode","title":"Interactive Mode","text":"<p>The simplest way to use grib-getter:</p> <pre><code>python fetch_forecast.py fetch\n</code></pre> <p>You'll be prompted for:</p> <ul> <li>Query preset (e.g., <code>sailing_basic</code>)</li> <li>Location (latitude, longitude, area size)</li> </ul>"},{"location":"quickstart/#non-interactive-mode","title":"Non-Interactive Mode","text":"<p>For automation or scripting:</p> <pre><code>python fetch_forecast.py fetch \\\n  -p sailing_basic \\\n  --lat 45 \\\n  --lon -93 \\\n  --height 90 \\\n  --width 180\n</code></pre>"},{"location":"quickstart/#bandwidth-saving-options","title":"Bandwidth-Saving Options","text":""},{"location":"quickstart/#check-only","title":"Check Only","text":"<p>See what's available without downloading:</p> <pre><code>python fetch_forecast.py fetch -p sailing_basic --check-only\n</code></pre> <p>Output: <pre><code>Target file: 20251106_18_000_GFS_sailing_basic.grib\nStatus: File does not exist locally\n</code></pre></p>"},{"location":"quickstart/#new-only","title":"New Only","text":"<p>Only download if file doesn't exist (perfect for cron jobs):</p> <pre><code>python fetch_forecast.py fetch -p sailing_basic --new-only\n</code></pre> <p>If file exists: <pre><code>File exists and --new-only specified. Skipping download.\nUsing existing file: /path/to/20251106_18_000_GFS_sailing_basic.grib\n</code></pre></p>"},{"location":"quickstart/#force-download","title":"Force Download","text":"<p>Download even if file exists (creates backup first):</p> <pre><code>python fetch_forecast.py fetch -p sailing_basic --force\n</code></pre> <p>Output: <pre><code>Backing up existing file...\n  Created backup: 20251106_18_000_GFS_sailing_basic.grib.00.bak\nFetching data...\n\u2713 Success! Downloaded 1,234,567 bytes in 2.3s\n</code></pre></p>"},{"location":"quickstart/#file-organization","title":"File Organization","text":"<p>Downloaded files are organized by run:</p> <pre><code>grib_data/\n\u2514\u2500\u2500 20251106_18_GFS_sailing_basic/\n    \u2514\u2500\u2500 20251106_18_000_GFS_sailing_basic.grib\n</code></pre> <p>Format: <code>YYYYMMDD_HH_FFF_{model}_{preset}.grib</code></p> <ul> <li><code>YYYYMMDD</code> - Forecast run date</li> <li><code>HH</code> - Forecast cycle hour (00, 06, 12, 18 for GFS)</li> <li><code>FFF</code> - Forecast hour (000 for analysis file)</li> <li><code>{model}</code> - Model name (GFS)</li> <li><code>{preset}</code> - Query preset (sailing_basic)</li> </ul>"},{"location":"quickstart/#available-presets","title":"Available Presets","text":"<p>List all available query presets:</p> <pre><code>python fetch_forecast.py list-presets\n</code></pre> <p>Currently available:</p> <ul> <li>sailing_basic - Essential marine weather variables (wind, pressure, temperature, waves)</li> </ul>"},{"location":"quickstart/#configuration","title":"Configuration","text":"<p>Change storage location:</p> <pre><code>python fetch_forecast.py configure --storage ~/weather\n</code></pre>"},{"location":"quickstart/#common-workflows","title":"Common Workflows","text":""},{"location":"quickstart/#daily-automated-fetch","title":"Daily Automated Fetch","text":"<p>For a cron job that downloads once per day:</p> <pre><code>0 8 * * * cd /path/to/grib-getter &amp;&amp; python fetch_forecast.py fetch -p sailing_basic --new-only\n</code></pre>"},{"location":"quickstart/#pre-departure-check","title":"Pre-Departure Check","text":"<p>Before setting sail, check and download latest:</p> <pre><code># Check what's available\npython fetch_forecast.py fetch -p sailing_basic --check-only\n\n# Download if needed\npython fetch_forecast.py fetch -p sailing_basic\n</code></pre>"},{"location":"quickstart/#bandwidth-constrained-update","title":"Bandwidth-Constrained Update","text":"<p>When bandwidth is expensive:</p> <pre><code># Check first\npython fetch_forecast.py fetch -p sailing_basic --check-only\n\n# Only download if doesn't exist\npython fetch_forecast.py fetch -p sailing_basic --new-only\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Guide - Customize settings</li> <li>Architecture - How it works</li> <li>API Reference - Detailed documentation</li> </ul>"},{"location":"api/cli/","title":"CLI Reference","text":"<p>Command-line interface for fetching NOAA GRIB forecasts.</p>"},{"location":"api/cli/#main-functions","title":"Main Functions","text":""},{"location":"api/cli/#fetch_forecast.fetch","title":"fetch","text":"<pre><code>fetch(preset: Annotated[str | None, Option(--preset, -p, help=\"Query preset name (e.g., 'sailing_basic'). If not provided, will prompt interactively.\")] = None, lat: Annotated[float | None, Option(--lat, help='Center latitude (-90 to 90)')] = None, lon: Annotated[float | None, Option(--lon, help='Center longitude (-180 to 180)')] = None, height: Annotated[float | None, Option(--height, help=Height in degrees)] = None, width: Annotated[float | None, Option(--width, help=Width in degrees)] = None, interactive: Annotated[bool, Option(--interactive / --no - interactive, -i / -I, help='Force interactive mode even if all options provided')] = False, force: Annotated[bool, Option(--force, -f, help='Force download even if file already exists locally')] = False, new_only: Annotated[bool, Option(--new - only, help=\"Only download if file doesn't exist locally\")] = False, check_only: Annotated[bool, Option(--check - only, help='Check what forecast is available on server without downloading')] = False) -&gt; None\n</code></pre> <p>Fetch NOAA GFS weather forecast data.</p> <p>Can be used interactively (prompts for all options) or with command-line arguments for automation.</p> <p>Examples:</p>"},{"location":"api/cli/#fetch_forecast.fetch--interactive-mode-default","title":"Interactive mode (default)","text":"<p>python fetch_forecast.py fetch</p>"},{"location":"api/cli/#fetch_forecast.fetch--non-interactive-with-all-options","title":"Non-interactive with all options","text":"<p>python fetch_forecast.py fetch -p sailing_basic --lat 45 --lon -93 --height 90 --width 180</p>"},{"location":"api/cli/#fetch_forecast.fetch--force-download-even-if-file-exists","title":"Force download even if file exists","text":"<p>python fetch_forecast.py fetch -p sailing_basic --force</p>"},{"location":"api/cli/#fetch_forecast.fetch--only-download-if-file-doesnt-exist-bandwidth-saving","title":"Only download if file doesn't exist (bandwidth-saving)","text":"<p>python fetch_forecast.py fetch -p sailing_basic --new-only</p>"},{"location":"api/cli/#fetch_forecast.fetch--check-whats-available-without-downloading","title":"Check what's available without downloading","text":"<p>python fetch_forecast.py fetch -p sailing_basic --check-only</p> Source code in <code>fetch_forecast.py</code> <pre><code>@app.command()\ndef fetch(\n    preset: Annotated[\n        str | None,\n        typer.Option(\n            \"--preset\",\n            \"-p\",\n            help=\"Query preset name (e.g., 'sailing_basic'). If not provided, will prompt interactively.\",\n        ),\n    ] = None,\n    lat: Annotated[\n        float | None,\n        typer.Option(\"--lat\", help=\"Center latitude (-90 to 90)\"),\n    ] = None,\n    lon: Annotated[\n        float | None,\n        typer.Option(\"--lon\", help=\"Center longitude (-180 to 180)\"),\n    ] = None,\n    height: Annotated[\n        float | None,\n        typer.Option(\"--height\", help=\"Height in degrees\"),\n    ] = None,\n    width: Annotated[\n        float | None,\n        typer.Option(\"--width\", help=\"Width in degrees\"),\n    ] = None,\n    interactive: Annotated[\n        bool,\n        typer.Option(\n            \"--interactive/--no-interactive\",\n            \"-i/-I\",\n            help=\"Force interactive mode even if all options provided\",\n        ),\n    ] = False,\n    force: Annotated[\n        bool,\n        typer.Option(\n            \"--force\",\n            \"-f\",\n            help=\"Force download even if file already exists locally\",\n        ),\n    ] = False,\n    new_only: Annotated[\n        bool,\n        typer.Option(\n            \"--new-only\",\n            help=\"Only download if file doesn't exist locally\",\n        ),\n    ] = False,\n    check_only: Annotated[\n        bool,\n        typer.Option(\n            \"--check-only\",\n            help=\"Check what forecast is available on server without downloading\",\n        ),\n    ] = False,\n) -&gt; None:\n    \"\"\"\n    Fetch NOAA GFS weather forecast data.\n\n    Can be used interactively (prompts for all options) or with command-line arguments\n    for automation.\n\n    Examples:\n        # Interactive mode (default)\n        python fetch_forecast.py fetch\n\n        # Non-interactive with all options\n        python fetch_forecast.py fetch -p sailing_basic --lat 45 --lon -93 --height 90 --width 180\n\n        # Force download even if file exists\n        python fetch_forecast.py fetch -p sailing_basic --force\n\n        # Only download if file doesn't exist (bandwidth-saving)\n        python fetch_forecast.py fetch -p sailing_basic --new-only\n\n        # Check what's available without downloading\n        python fetch_forecast.py fetch -p sailing_basic --check-only\n    \"\"\"\n    setup_logging()\n\n    console.print(\"[bold blue]grib-getter: NOAA Weather Forecast Fetcher[/bold blue]\\n\")\n\n    # Ensure storage path is configured (first-run setup if needed)\n    storage_path = ensure_storage_configured()\n\n    # Determine if we need interactive prompts\n    need_preset = preset is None\n    need_location = any(x is None for x in [lat, lon, height, width])\n\n    if interactive or need_preset or need_location:\n        # Interactive mode\n        if need_preset:\n            preset = prompt_for_query_preset()\n\n        if need_location:\n            location = prompt_for_location()\n        else:\n            location = nqb.LocationSettings(\n                center_lat=lat,  # type: ignore\n                center_lon=lon,  # type: ignore\n                height_degrees=height,  # type: ignore\n                width_degrees=width,  # type: ignore\n            )\n    else:\n        # Fully non-interactive\n        location = nqb.LocationSettings(\n            center_lat=lat,  # type: ignore\n            center_lon=lon,  # type: ignore\n            height_degrees=height,  # type: ignore\n            width_degrees=width,  # type: ignore\n        )\n\n    # Display configuration summary\n    console.print(f\"\\n[bold]Configuration:[/bold]\")\n    console.print(f\"  Model: [green]{settings.defaults.model_name}[/green] (auto-selected)\")\n    console.print(f\"  Product: [green]{settings.defaults.product_name}[/green] (auto-selected)\")\n    console.print(f\"  Preset: [green]{preset}[/green]\")\n    console.print(\n        f\"  Location: [green]{location.center_lat}, {location.center_lon}[/green] \"\n        f\"({location.width_degrees}\u00b0 \u00d7 {location.height_degrees}\u00b0)\"\n    )\n\n    # Load model data and query mask from configuration\n    model_data = nqb.ModelData.model_validate(settings.GFS_DATA)\n    query_mask = nqb.QueryMask.model_validate(getattr(settings.GFS_QUERIES, preset))\n\n    # Build query structure for NOAA API\n    qs = nqb.QueryStructure(\n        bounding_box=nqb.create_bounding_box(ls=location),\n        query_model=nqb.QueryModel.model_validate(\n            settings.GFS_PRODUCTS.gfs_quarter_degree,\n        ),\n        variables=nqb.SelectedKeys(\n            all_keys=model_data.variables,\n            hex_mask=query_mask.variables,\n            prefix=settings.query.var_prefix,\n        ),\n        levels=nqb.SelectedKeys(\n            all_keys=model_data.levels,\n            hex_mask=query_mask.levels,\n            prefix=settings.query.lev_prefix,\n        ),\n        current_time=dt.datetime.now(tz=dt.timezone.utc),\n        settings=nqb.CoreSettings.model_validate(settings.core_settings),\n    )\n\n    # Generate query URLs (tries most recent to older forecasts)\n    query_urls = nqb.generate_query_urls(\n        qt_batch=nqb.generate_qt_batch(reference_time=qs.current_time, qs=qs),\n        qs=qs,\n    )\n\n    # Generate output path in run-specific folder\n    latest_forecast = nqb.get_latest_run_start(\n        dt.datetime.now(tz=dt.timezone.utc), qs\n    )\n    output_path = generate_output_filename(\n        model_name=settings.defaults.model_name,\n        product_name=settings.defaults.product_name,\n        preset_name=preset,\n        forecast_time=latest_forecast,\n        forecast_hour=0,  # Analysis file is hour 000\n        storage_path=storage_path,\n    )\n\n    console.print(f\"\\n[bold]Target file:[/bold]\")\n    console.print(f\"  Path: [cyan]{output_path}[/cyan]\")\n    console.print(f\"  Forecast time: [cyan]{latest_forecast.strftime('%Y-%m-%d %H:00 UTC')}[/cyan]\")\n\n    # Check if file already exists locally\n    file_exists = output_path.exists()\n    if file_exists:\n        file_size = output_path.stat().st_size\n        console.print(f\"  Status: [yellow]File already exists ({file_size:,} bytes)[/yellow]\")\n    else:\n        console.print(f\"  Status: [dim]File does not exist locally[/dim]\")\n\n    # Handle check-only mode (no download, just report)\n    if check_only:\n        console.print(f\"\\n[bold]Check-only mode:[/bold] No download will be performed\")\n        if file_exists:\n            console.print(f\"[green]\u2713[/green] Latest forecast file exists locally\")\n        else:\n            console.print(f\"[yellow]![/yellow] Latest forecast file not found locally\")\n        raise typer.Exit(code=0)\n\n    # Handle existing file (bandwidth optimization)\n    if file_exists and not force:\n        if new_only:\n            # --new-only flag: skip if file exists (for automated scripts)\n            console.print(f\"\\n[yellow]File exists and --new-only specified. Skipping download.[/yellow]\")\n            console.print(f\"  Using existing file: [cyan]{output_path}[/cyan]\")\n            raise typer.Exit(code=0)\n        else:\n            # Interactive mode: ask user what to do\n            console.print(f\"\\n[bold yellow]File already exists![/bold yellow]\")\n            choice = Prompt.ask(\n                \"What would you like to do?\",\n                choices=[\"download\", \"skip\", \"cancel\"],\n                default=\"skip\",\n            )\n            if choice == \"skip\":\n                console.print(f\"[green]Using existing file: {output_path}[/green]\")\n                raise typer.Exit(code=0)\n            elif choice == \"cancel\":\n                console.print(\"[red]Cancelled[/red]\")\n                raise typer.Exit(code=1)\n            # choice == \"download\" falls through\n\n    # Create backup before overwriting (data integrity protection)\n    if file_exists:\n        console.print(f\"\\n[bold]Backing up existing file...[/bold]\")\n        create_backup_file(output_path)\n\n    console.print(f\"\\n[bold]Fetching data...[/bold]\")\n\n    # Fetch data\n    result = ngf.fetch_with_timeout(\n        query_urls=query_urls,\n        output_path=output_path,\n    )\n\n    # Report results\n    if result.success and result.data:\n        console.print(\n            f\"\\n[bold green]\u2713 Success![/bold green] \"\n            f\"Downloaded {len(result.data):,} bytes in {result.total_duration_seconds:.1f}s\"\n        )\n        console.print(f\"  File: [cyan]{output_path}[/cyan]\")\n    else:\n        console.print(\n            f\"\\n[bold red]\u2717 Failed[/bold red] after {len(result.attempts)} attempts \"\n            f\"in {result.total_duration_seconds:.1f}s\"\n        )\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"api/cli/#fetch_forecast.configure","title":"configure","text":"<pre><code>configure(storage_path: Annotated[str | None, Option(--storage, -s, help='Set GRIB file storage directory path')] = None) -&gt; None\n</code></pre> <p>Configure grib-getter settings.</p> <p>Use this to set or change the GRIB file storage directory. If no path provided, will prompt interactively.</p> <p>Examples:</p>"},{"location":"api/cli/#fetch_forecast.configure--interactive-configuration","title":"Interactive configuration","text":"<p>grib-getter configure</p>"},{"location":"api/cli/#fetch_forecast.configure--set-storage-path-directly","title":"Set storage path directly","text":"<p>grib-getter configure --storage /path/to/grib_data</p> Source code in <code>fetch_forecast.py</code> <pre><code>@app.command()\ndef configure(\n    storage_path: Annotated[\n        str | None,\n        typer.Option(\n            \"--storage\",\n            \"-s\",\n            help=\"Set GRIB file storage directory path\",\n        ),\n    ] = None,\n) -&gt; None:\n    \"\"\"\n    Configure grib-getter settings.\n\n    Use this to set or change the GRIB file storage directory.\n    If no path provided, will prompt interactively.\n\n    Examples:\n        # Interactive configuration\n        grib-getter configure\n\n        # Set storage path directly\n        grib-getter configure --storage /path/to/grib_data\n    \"\"\"\n    setup_logging()\n\n    console.print(\"[bold blue]grib-getter Configuration[/bold blue]\\n\")\n\n    if storage_path is None:\n        # Interactive mode\n        current_path = get_storage_path()\n        if current_path:\n            console.print(f\"Current storage path: [cyan]{current_path}[/cyan]\\n\")\n\n        default_path = current_path or Path.cwd() / settings.defaults.grib_dir\n        path_input = Prompt.ask(\n            \"Storage directory for GRIB files\",\n            default=str(default_path),\n        )\n        storage_path = path_input\n\n    # Convert to Path and expand/resolve\n    new_path = Path(storage_path).expanduser().resolve()\n\n    # Create directory if it doesn't exist\n    if not new_path.exists():\n        if Confirm.ask(f\"\\nDirectory doesn't exist. Create {new_path}?\", default=True):\n            new_path.mkdir(parents=True, exist_ok=True)\n            console.print(f\"[green]\u2713[/green] Created directory: {new_path}\")\n        else:\n            console.print(\"[red]Configuration cancelled[/red]\")\n            raise typer.Exit(code=1)\n\n    # Save configuration\n    save_storage_path(new_path)\n    console.print(\"\\n[green]\u2713 Configuration complete![/green]\")\n</code></pre>"},{"location":"api/cli/#fetch_forecast.list_presets","title":"list_presets","text":"<pre><code>list_presets() -&gt; None\n</code></pre> <p>List available query presets.</p> Source code in <code>fetch_forecast.py</code> <pre><code>@app.command()\ndef list_presets() -&gt; None:\n    \"\"\"List available query presets.\"\"\"\n    console.print(\"[bold]Available Query Presets:[/bold]\\n\")\n    for preset in get_available_query_presets():\n        console.print(f\"  \u2022 {preset}\")\n</code></pre>"},{"location":"api/cli/#helper-functions","title":"Helper Functions","text":""},{"location":"api/cli/#fetch_forecast.ensure_storage_configured","title":"ensure_storage_configured","text":"<pre><code>ensure_storage_configured() -&gt; Path\n</code></pre> <p>Ensure storage path is configured. Prompts user if not set.</p> <p>First-run setup: prompts for storage directory and saves to settings. Must reload settings after saving to pick up the new configuration.</p> <p>Returns:</p> Type Description <code>Path</code> <p>Configured storage path</p> Source code in <code>fetch_forecast.py</code> <pre><code>def ensure_storage_configured() -&gt; Path:\n    \"\"\"\n    Ensure storage path is configured. Prompts user if not set.\n\n    First-run setup: prompts for storage directory and saves to settings.\n    Must reload settings after saving to pick up the new configuration.\n\n    Returns:\n        Configured storage path\n    \"\"\"\n    global settings\n    storage_path = get_storage_path()\n\n    if storage_path is None:\n        console.print(\"\\n[bold yellow]First-time setup required[/bold yellow]\")\n        console.print(\"Please configure where GRIB files should be stored.\\n\")\n\n        default_path = Path.cwd() / settings.defaults.grib_dir\n        path_input = Prompt.ask(\n            \"Storage directory for GRIB files\",\n            default=str(default_path),\n        )\n\n        storage_path = Path(path_input).expanduser().resolve()\n\n        # Create directory if it doesn't exist\n        if not storage_path.exists():\n            if Confirm.ask(f\"Directory doesn't exist. Create {storage_path}?\", default=True):\n                storage_path.mkdir(parents=True, exist_ok=True)\n                console.print(f\"[green]\u2713[/green] Created directory: {storage_path}\")\n            else:\n                console.print(\"[red]Setup cancelled[/red]\")\n                raise typer.Exit(code=1)\n\n        save_storage_path(storage_path)\n\n        # Reload settings to pick up the new output_dir value from user.toml\n        from dynaconf import Dynaconf\n        settings = Dynaconf(\n            envvar_prefix=\"DYNACONF\",\n            settings_files=[\"settings.toml\", \"user.toml\", \".secrets.toml\", \"settings/*.toml\"],\n            merge_enabled=True,\n        )\n\n    return storage_path\n</code></pre>"},{"location":"api/cli/#fetch_forecast.save_storage_path","title":"save_storage_path","text":"<pre><code>save_storage_path(storage_path: Path) -&gt; None\n</code></pre> <p>Save storage path to user.toml file.</p> <p>Separates user configuration (output_dir) from application configuration. This avoids polluting version-controlled settings.toml with user paths.</p> Source code in <code>fetch_forecast.py</code> <pre><code>def save_storage_path(storage_path: Path) -&gt; None:\n    \"\"\"\n    Save storage path to user.toml file.\n\n    Separates user configuration (output_dir) from application configuration.\n    This avoids polluting version-controlled settings.toml with user paths.\n    \"\"\"\n    import tomli\n\n    user_config_file = Path(\"user.toml\")\n\n    # Read current user config\n    if user_config_file.exists():\n        with open(user_config_file, \"rb\") as f:\n            config = tomli.load(f)\n    else:\n        config = {}\n\n    # Ensure core_settings section exists\n    if \"core_settings\" not in config:\n        config[\"core_settings\"] = {}\n\n    # Update output_dir\n    config[\"core_settings\"][\"output_dir\"] = str(storage_path)\n\n    # Write to user.toml\n    with open(user_config_file, \"wb\") as f:\n        tomli_w.dump(config, f)\n\n    console.print(f\"[green]\u2713[/green] Storage path configured: [cyan]{storage_path}[/cyan]\")\n</code></pre>"},{"location":"api/cli/#fetch_forecast.generate_output_filename","title":"generate_output_filename","text":"<pre><code>generate_output_filename(model_name: str, product_name: str, preset_name: str, forecast_time: datetime, forecast_hour: int, storage_path: Path) -&gt; Path\n</code></pre> <p>Generate output filename in run-specific folder structure.</p> <p>New structure for async batch downloading support: - Folder: YYYYMMDD_HH_{model_name}{preset_name}/ - File: YYYYMMDD_HH_FFF{model_name}_{preset_name}.grib   where FFF is the forecast hour (000 for analysis, 001, 006, 012, etc.)</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>Model identifier (e.g., 'GFS')</p> required <code>product_name</code> <code>str</code> <p>Product identifier (e.g., 'gfs_quarter_degree')</p> required <code>preset_name</code> <code>str</code> <p>Query preset name (e.g., 'sailing_basic')</p> required <code>forecast_time</code> <code>datetime</code> <p>Forecast run datetime</p> required <code>forecast_hour</code> <code>int</code> <p>Forecast hour (0 for analysis file)</p> required <code>storage_path</code> <code>Path</code> <p>Base directory where GRIB files are stored</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to output file in run-specific subdirectory</p> Source code in <code>fetch_forecast.py</code> <pre><code>def generate_output_filename(\n    model_name: str,\n    product_name: str,\n    preset_name: str,\n    forecast_time: dt.datetime,\n    forecast_hour: int,\n    storage_path: Path,\n) -&gt; Path:\n    \"\"\"\n    Generate output filename in run-specific folder structure.\n\n    New structure for async batch downloading support:\n    - Folder: YYYYMMDD_HH_{model_name}_{preset_name}/\n    - File: YYYYMMDD_HH_FFF_{model_name}_{preset_name}.grib\n      where FFF is the forecast hour (000 for analysis, 001, 006, 012, etc.)\n\n    Args:\n        model_name: Model identifier (e.g., 'GFS')\n        product_name: Product identifier (e.g., 'gfs_quarter_degree')\n        preset_name: Query preset name (e.g., 'sailing_basic')\n        forecast_time: Forecast run datetime\n        forecast_hour: Forecast hour (0 for analysis file)\n        storage_path: Base directory where GRIB files are stored\n\n    Returns:\n        Path to output file in run-specific subdirectory\n    \"\"\"\n    date_part = forecast_time.strftime(\"%Y%m%d\")\n    hour_part = forecast_time.strftime(\"%H\")\n\n    # Create run-specific folder name\n    folder_name = f\"{date_part}_{hour_part}_{model_name}_{preset_name}\"\n    run_folder = storage_path / folder_name\n\n    # Create filename with forecast hour\n    filename = f\"{date_part}_{hour_part}_{forecast_hour:03d}_{model_name}_{preset_name}.grib\"\n\n    return run_folder / filename\n</code></pre>"},{"location":"api/cli/#fetch_forecast.create_backup_file","title":"create_backup_file","text":"<pre><code>create_backup_file(original_path: Path) -&gt; Path\n</code></pre> <p>Create a backup of an existing file before overwriting.</p> <p>Critical for bandwidth-limited environments where corrupted downloads could lose good data from earlier successful downloads.</p> <p>Backup naming: {original_name}.{NN}.bak where NN is 00 to max_count-1 Finds next available number; if all slots used, overwrites the last one.</p> <p>Backup settings (max_count, extension) configured in settings.toml.</p> <p>Parameters:</p> Name Type Description Default <code>original_path</code> <code>Path</code> <p>Path to file that will be backed up</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to created backup file</p> Source code in <code>fetch_forecast.py</code> <pre><code>def create_backup_file(original_path: Path) -&gt; Path:\n    \"\"\"\n    Create a backup of an existing file before overwriting.\n\n    Critical for bandwidth-limited environments where corrupted downloads\n    could lose good data from earlier successful downloads.\n\n    Backup naming: {original_name}.{NN}.bak where NN is 00 to max_count-1\n    Finds next available number; if all slots used, overwrites the last one.\n\n    Backup settings (max_count, extension) configured in settings.toml.\n\n    Args:\n        original_path: Path to file that will be backed up\n\n    Returns:\n        Path to created backup file\n    \"\"\"\n    # Find next available backup number\n    backup_num = 0\n    while backup_num &lt; settings.backup.max_count:\n        backup_path = Path(f\"{original_path}.{backup_num:02d}{settings.backup.extension}\")\n        if not backup_path.exists():\n            break\n        backup_num += 1\n    else:\n        # If all backup slots full, overwrite the last one\n        final_backup_num = settings.backup.max_count - 1\n        backup_path = Path(f\"{original_path}.{final_backup_num:02d}{settings.backup.extension}\")\n\n    # Create backup by renaming original\n    original_path.rename(backup_path)\n    console.print(f\"  [dim]Created backup: {backup_path.name}[/dim]\")\n\n    return backup_path\n</code></pre>"},{"location":"api/cli/#fetch_forecast.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging() -&gt; None\n</code></pre> <p>Configure loguru with rich handler for enhanced console output.</p> <p>Should be called once at application entry point.</p> Source code in <code>fetch_forecast.py</code> <pre><code>def setup_logging() -&gt; None:\n    \"\"\"\n    Configure loguru with rich handler for enhanced console output.\n\n    Should be called once at application entry point.\n    \"\"\"\n    # Remove default handler\n    logger.remove()\n\n    # Add rich handler for beautiful console output\n    logger.add(\n        RichHandler(\n            console=console,\n            rich_tracebacks=True,\n            tracebacks_show_locals=True,\n        ),\n        format=\"{message}\",\n        level=\"INFO\",\n    )\n</code></pre>"},{"location":"api/cli/#fetch_forecast.get_storage_path","title":"get_storage_path","text":"<pre><code>get_storage_path() -&gt; Path | None\n</code></pre> <p>Get configured storage path, or None if not configured.</p> Source code in <code>fetch_forecast.py</code> <pre><code>def get_storage_path() -&gt; Path | None:\n    \"\"\"Get configured storage path, or None if not configured.\"\"\"\n    try:\n        return Path(settings.core_settings.output_dir)\n    except (AttributeError, KeyError):\n        return None\n</code></pre>"},{"location":"api/cli/#fetch_forecast.get_available_query_presets","title":"get_available_query_presets","text":"<pre><code>get_available_query_presets() -&gt; list[str]\n</code></pre> <p>Get list of available query preset names from GFS settings.</p> Source code in <code>fetch_forecast.py</code> <pre><code>def get_available_query_presets() -&gt; list[str]:\n    \"\"\"Get list of available query preset names from GFS settings.\"\"\"\n    return list(settings.GFS_QUERIES.keys())\n</code></pre>"},{"location":"api/cli/#fetch_forecast.prompt_for_query_preset","title":"prompt_for_query_preset","text":"<pre><code>prompt_for_query_preset() -&gt; str\n</code></pre> <p>Interactively prompt user to select a query preset.</p> <p>Auto-selects if only one preset available, otherwise shows numbered menu.</p> Source code in <code>fetch_forecast.py</code> <pre><code>def prompt_for_query_preset() -&gt; str:\n    \"\"\"\n    Interactively prompt user to select a query preset.\n\n    Auto-selects if only one preset available, otherwise shows numbered menu.\n    \"\"\"\n    presets = get_available_query_presets()\n\n    if len(presets) == 1:\n        console.print(f\"[dim]Auto-selecting query preset: {presets[0]}[/dim]\")\n        return presets[0]\n\n    console.print(\"\\n[bold]Available Query Presets:[/bold]\")\n    for i, preset in enumerate(presets, 1):\n        console.print(f\"  {i}. {preset}\")\n\n    while True:\n        choice = Prompt.ask(\n            \"\\nSelect preset\",\n            choices=[str(i) for i in range(1, len(presets) + 1)],\n            default=\"1\",\n        )\n        return presets[int(choice) - 1]\n</code></pre>"},{"location":"api/cli/#fetch_forecast.prompt_for_location","title":"prompt_for_location","text":"<pre><code>prompt_for_location() -&gt; nqb.LocationSettings\n</code></pre> <p>Interactively prompt user for location parameters.</p> <p>Uses center point + expanse format (more intuitive than bounding box). Defaults pulled from settings.DEFAULT_LOCATION.</p> Source code in <code>fetch_forecast.py</code> <pre><code>def prompt_for_location() -&gt; nqb.LocationSettings:\n    \"\"\"\n    Interactively prompt user for location parameters.\n\n    Uses center point + expanse format (more intuitive than bounding box).\n    Defaults pulled from settings.DEFAULT_LOCATION.\n    \"\"\"\n    console.print(\"\\n[bold]Location Configuration[/bold]\")\n    console.print(\"[dim]Using center point + expanse format[/dim]\")\n\n    # Get defaults from settings\n    defaults = settings.DEFAULT_LOCATION\n\n    center_lat = float(\n        Prompt.ask(\n            \"Center latitude (-90 to 90)\",\n            default=str(defaults.center_lat),\n        )\n    )\n    center_lon = float(\n        Prompt.ask(\n            \"Center longitude (-180 to 180)\",\n            default=str(defaults.center_lon),\n        )\n    )\n    height_degrees = float(\n        Prompt.ask(\n            \"Height in degrees\",\n            default=str(defaults.height_degrees),\n        )\n    )\n    width_degrees = float(\n        Prompt.ask(\n            \"Width in degrees\",\n            default=str(defaults.width_degrees),\n        )\n    )\n\n    return nqb.LocationSettings(\n        center_lat=center_lat,\n        center_lon=center_lon,\n        height_degrees=height_degrees,\n        width_degrees=width_degrees,\n    )\n</code></pre>"},{"location":"api/config/","title":"Configuration Reference","text":"<p>Configuration management with Dynaconf.</p>"},{"location":"api/config/#settings-object","title":"Settings Object","text":"<p>The <code>settings</code> object provides access to all configuration values loaded from:</p> <ul> <li><code>settings.toml</code> - Application defaults (version controlled)</li> <li><code>user.toml</code> - User-specific config (gitignored)</li> <li><code>.secrets.toml</code> - Secrets (gitignored)</li> <li><code>settings/*.toml</code> - Model configs (auto-discovered)</li> </ul>"},{"location":"api/config/#usage","title":"Usage","text":"<pre><code>from config import settings\n\n# Access core settings\noutput_dir = settings.core_settings.output_dir\ngrib_url = settings.core_settings.grib_url\n\n# Access GFS model data\nvariables = settings.GFS_DATA.variables\nlevels = settings.GFS_DATA.levels\n\n# Access GFS queries\nsailing_vars = settings.GFS_QUERIES.sailing_basic.variables\nsailing_levels = settings.GFS_QUERIES.sailing_basic.levels\n\n# Access GFS products\nproduct_info = settings.GFS_PRODUCTS.gfs_quarter_degree\n</code></pre>"},{"location":"api/config/#configuration-sections","title":"Configuration Sections","text":""},{"location":"api/config/#core-settings","title":"Core Settings","text":""},{"location":"api/config/#config-attributes","title":"Attributes","text":""},{"location":"api/config/#config.settings","title":"settings  <code>module-attribute</code>","text":"<pre><code>settings = Dynaconf(envvar_prefix='DYNACONF', settings_files=['settings.toml', 'user.toml', '.secrets.toml', 'settings/*.toml'], merge_enabled=True)\n</code></pre>"},{"location":"api/config/#configuration-files","title":"Configuration Files","text":""},{"location":"api/config/#settingstoml","title":"settings.toml","text":"<p>Application defaults (version controlled):</p> <pre><code>[core_settings]\ngrib_url = \"https://nomads.ncep.noaa.gov/cgi-bin/{filter}\"\nforecast_interval_hours = 6\nmax_lookback_hours = 18\n\n[http_settings]\nsuccess = 200\nnot_found = 404\nserver_error = 500\nrequest_timeout_seconds = 30\n\n[noaa_settings]\nrate_limit_seconds = 10\n\n[retry_settings]\nmax_attempts = 3\ninitial_delay_seconds = 5\nmax_delay_seconds = 300\ntimeout_minutes = 30\n\n[default_location]\ncenter_lat = 45.0\ncenter_lon = -93.0\nheight_degrees = 90.0\nwidth_degrees = 180.0\n\n[defaults]\ngrib_dir = \"grib_data\"\nmodel_name = \"GFS\"\nproduct_name = \"gfs_quarter_degree\"\n\n[backup]\nmax_count = 100\nextension = \".bak\"\n\n[query]\nvar_prefix = \"var_\"\nlev_prefix = \"lev_\"\n</code></pre>"},{"location":"api/config/#usertoml","title":"user.toml","text":"<p>User-specific configuration (gitignored, auto-created):</p> <pre><code>[core_settings]\noutput_dir = \"/path/to/grib_data\"\n</code></pre>"},{"location":"api/config/#settingsgfstoml","title":"settings/gfs.toml","text":"<p>GFS model configuration (auto-discovered):</p> <p>See Adding Models for structure and examples.</p>"},{"location":"api/config/#environment-variables","title":"Environment Variables","text":"<p>Override any setting with environment variables using <code>DYNACONF_</code> prefix:</p> <pre><code>export DYNACONF_CORE_SETTINGS__OUTPUT_DIR=/tmp/grib_data\nexport DYNACONF_RETRY_SETTINGS__MAX_ATTEMPTS=5\n</code></pre>"},{"location":"api/config/#configuration-merging","title":"Configuration Merging","text":"<p>Dynaconf merges nested dictionaries from all configuration files. Later files override earlier ones:</p> <ol> <li><code>settings.toml</code> (defaults)</li> <li><code>user.toml</code> (overrides)</li> <li><code>.secrets.toml</code> (overrides)</li> <li><code>settings/*.toml</code> (model-specific, merged)</li> <li>Environment variables (highest priority)</li> </ol>"},{"location":"api/fetcher/","title":"GRIB Fetcher Reference","text":"<p>HTTP fetching with retry logic and rate limiting for NOAA GRIB data.</p>"},{"location":"api/fetcher/#exceptions","title":"Exceptions","text":""},{"location":"api/fetcher/#noaa_grib_fetcher.ForecastDataUnavailable","title":"ForecastDataUnavailable","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when no forecast data is available after all retries.</p>"},{"location":"api/fetcher/#noaa_grib_fetcher.NOAAServerError","title":"NOAAServerError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when NOAA server returns 5xx error.</p>"},{"location":"api/fetcher/#data-models","title":"Data Models","text":""},{"location":"api/fetcher/#noaa_grib_fetcher.FetchAttempt","title":"FetchAttempt","text":"<p>               Bases: <code>BaseModel</code></p> <p>Record of a single fetch attempt.</p> <p>Tracks URL, status code, error type, and timestamp for debugging.</p>"},{"location":"api/fetcher/#noaa_grib_fetcher.FetchResult","title":"FetchResult","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result of fetch operation with metadata.</p> <p>Includes data bytes (if successful), all attempt records, success flag, and total duration for performance tracking.</p>"},{"location":"api/fetcher/#main-functions","title":"Main Functions","text":""},{"location":"api/fetcher/#noaa_grib_fetcher.fetch_most_recent_forecast","title":"fetch_most_recent_forecast","text":"<pre><code>fetch_most_recent_forecast(query_urls: Iterator[str], output_path: Path) -&gt; FetchResult\n</code></pre> <p>Try each query URL until one succeeds, with retry logic.</p> <p>Implements intelligent fallback: tries most recent forecast first, then progressively older forecasts. Most recent forecasts are often not yet available on NOAA servers, so this fallback is critical.</p> <p>Features: - Exponential backoff on transient errors (5xx, timeout) - Rate limiting between different forecast times (NOAA requirement) - Comprehensive attempt tracking for debugging</p> <p>Returns:</p> Type Description <code>FetchResult</code> <p>FetchResult with data (if successful) and all attempt metadata</p> Source code in <code>noaa_grib_fetcher.py</code> <pre><code>def fetch_most_recent_forecast(\n    query_urls: Iterator[str],\n    output_path: Path,\n) -&gt; FetchResult:\n    \"\"\"\n    Try each query URL until one succeeds, with retry logic.\n\n    Implements intelligent fallback: tries most recent forecast first, then\n    progressively older forecasts. Most recent forecasts are often not yet\n    available on NOAA servers, so this fallback is critical.\n\n    Features:\n    - Exponential backoff on transient errors (5xx, timeout)\n    - Rate limiting between different forecast times (NOAA requirement)\n    - Comprehensive attempt tracking for debugging\n\n    Returns:\n        FetchResult with data (if successful) and all attempt metadata\n    \"\"\"\n    start_time = time.time()\n    all_attempts: list[FetchAttempt] = []\n    first_url = True\n    url_count = 0\n\n    for url in query_urls:\n        url_count += 1\n\n        # Rate limiting: wait between requests (NOAA requires 10s minimum)\n        if not first_url:\n            logger.debug(\n                f\"Rate limit: waiting {settings.noaa_settings.rate_limit_seconds}s...\"\n            )\n            time.sleep(settings.noaa_settings.rate_limit_seconds)\n        first_url = False\n\n        # Try this URL with retry logic\n        response, attempts = fetch_with_exponential_backoff(url)\n        all_attempts.extend(attempts)\n\n        if (\n            response is not None\n            and response.status_code == settings.http_settings.success\n        ):\n            # Success! Save and return\n            output_path.parent.mkdir(parents=True, exist_ok=True)\n            output_path.write_bytes(response.content)\n\n            duration = time.time() - start_time\n            logger.info(f\"Successfully downloaded to {output_path}\")\n\n            return FetchResult(\n                data=response.content,\n                attempts=all_attempts,\n                success=True,\n                total_duration_seconds=duration,\n            )\n\n    # All URLs failed\n    duration = time.time() - start_time\n    logger.error(\n        f\"Failed to fetch forecast after {len(all_attempts)} attempts \"\n        f\"across {url_count} forecast times\"\n    )\n\n    return FetchResult(\n        data=None,\n        attempts=all_attempts,\n        success=False,\n        total_duration_seconds=duration,\n    )\n</code></pre>"},{"location":"api/fetcher/#noaa_grib_fetcher.fetch_with_retry","title":"fetch_with_retry","text":"<pre><code>fetch_with_retry(url: str, attempt_number: int = 0) -&gt; tuple[httpx.Response | None, FetchAttempt]\n</code></pre> <p>Fetch URL with error handling and logging.</p> <p>Returns response and attempt record. Response is None on failure.</p> Source code in <code>noaa_grib_fetcher.py</code> <pre><code>def fetch_with_retry(\n    url: str,\n    attempt_number: int = 0,\n) -&gt; tuple[httpx.Response | None, FetchAttempt]:\n    \"\"\"\n    Fetch URL with error handling and logging.\n\n    Returns response and attempt record. Response is None on failure.\n    \"\"\"\n    attempt = FetchAttempt(\n        url=url,\n        status_code=None,\n        error_type=None,\n        timestamp=datetime.now(timezone.utc),\n    )\n\n    try:\n        logger.info(f\"Fetching (attempt {attempt_number + 1}): {url}\")\n\n        response = httpx.get(\n            url,\n            timeout=settings.http_settings.request_timeout_seconds,\n            follow_redirects=True,\n        )\n\n        attempt.status_code = response.status_code\n\n        if response.status_code == settings.http_settings.success:\n            logger.info(f\"Success: {len(response.content):,} bytes received\")\n            return response, attempt\n\n        elif response.status_code == settings.http_settings.not_found:\n            logger.warning(\"Data not found (404) - forecast likely not available yet\")\n            return None, attempt\n\n        elif response.status_code &gt;= settings.http_settings.server_error:\n            logger.error(f\"Server error ({response.status_code})\")\n            attempt.error_type = \"server_error\"\n            return None, attempt\n\n        else:\n            logger.warning(f\"Unexpected status code: {response.status_code}\")\n            attempt.error_type = \"client_error\"\n            return None, attempt\n\n    except httpx.TimeoutException:\n        logger.error(\n            f\"Request timeout after {settings.http_settings.request_timeout_seconds}s\"\n        )\n        attempt.error_type = \"timeout\"\n        return None, attempt\n\n    except httpx.NetworkError as e:\n        logger.error(f\"Network error: {e}\")\n        attempt.error_type = \"network_error\"\n        return None, attempt\n\n    except Exception as e:\n        logger.error(f\"Unexpected error: {type(e).__name__}: {e}\")\n        attempt.error_type = \"unknown_error\"\n        return None, attempt\n</code></pre>"},{"location":"api/fetcher/#noaa_grib_fetcher.fetch_with_exponential_backoff","title":"fetch_with_exponential_backoff","text":"<pre><code>fetch_with_exponential_backoff(url: str, max_attempts: int | None = None) -&gt; tuple[httpx.Response | None, list[FetchAttempt]]\n</code></pre> <p>Fetch URL with exponential backoff retry logic.</p> <p>Only retries on transient errors (5xx, timeout, network). Does not retry on 404 or other client errors.</p> Source code in <code>noaa_grib_fetcher.py</code> <pre><code>def fetch_with_exponential_backoff(\n    url: str,\n    max_attempts: int | None = None,\n) -&gt; tuple[httpx.Response | None, list[FetchAttempt]]:\n    \"\"\"\n    Fetch URL with exponential backoff retry logic.\n\n    Only retries on transient errors (5xx, timeout, network).\n    Does not retry on 404 or other client errors.\n    \"\"\"\n    if max_attempts is None:\n        max_attempts = settings.retry_settings.max_attempts\n\n    attempts: list[FetchAttempt] = []\n\n    for attempt_num in range(max_attempts):\n        response, attempt = fetch_with_retry(url, attempt_num)\n        attempts.append(attempt)\n\n        if response is not None:\n            return response, attempts\n\n        # Check if we should retry\n        if attempt.status_code and not should_retry_status_code(attempt.status_code):\n            logger.debug(\"Status code does not warrant retry\")\n            break\n\n        # Don't sleep after last attempt\n        if attempt_num &lt; max_attempts - 1:\n            delay = calculate_exponential_backoff(attempt_num)\n            logger.info(f\"Retrying in {delay:.1f} seconds...\")\n            time.sleep(delay)\n\n    return None, attempts\n</code></pre>"},{"location":"api/fetcher/#noaa_grib_fetcher.fetch_with_timeout","title":"fetch_with_timeout","text":"<pre><code>fetch_with_timeout(query_urls: Iterator[str], output_path: Path, timeout_minutes: float | None = None) -&gt; FetchResult\n</code></pre> <p>Fetch with overall timeout across all retries.</p> <p>Useful for automated scripts that need predictable failure times rather than exhausting all retries (which could take a long time).</p> <p>Note: Uses SIGALRM which only works on Unix systems. On Windows, falls back to no timeout.</p> Source code in <code>noaa_grib_fetcher.py</code> <pre><code>def fetch_with_timeout(\n    query_urls: Iterator[str],\n    output_path: Path,\n    timeout_minutes: float | None = None,\n) -&gt; FetchResult:\n    \"\"\"\n    Fetch with overall timeout across all retries.\n\n    Useful for automated scripts that need predictable failure times\n    rather than exhausting all retries (which could take a long time).\n\n    Note: Uses SIGALRM which only works on Unix systems. On Windows,\n    falls back to no timeout.\n    \"\"\"\n    import signal\n\n    if timeout_minutes is None:\n        timeout_minutes = settings.retry_settings.timeout_minutes\n\n    def timeout_handler(signum, frame):\n        raise TimeoutError(f\"Fetch exceeded {timeout_minutes} minute timeout\")\n\n    # Set alarm (Unix/Mac only - gracefully degrades on Windows)\n    try:\n        signal.signal(signal.SIGALRM, timeout_handler)\n        signal.alarm(int(timeout_minutes * 60))\n\n        result = fetch_most_recent_forecast(query_urls, output_path)\n\n        signal.alarm(0)  # Cancel alarm\n        return result\n\n    except AttributeError:\n        # Windows or signal not available - just run without timeout\n        logger.warning(\"Timeout not supported on this platform, running without\")\n        return fetch_most_recent_forecast(query_urls, output_path)\n</code></pre>"},{"location":"api/fetcher/#helper-functions","title":"Helper Functions","text":""},{"location":"api/fetcher/#noaa_grib_fetcher.calculate_exponential_backoff","title":"calculate_exponential_backoff","text":"<pre><code>calculate_exponential_backoff(attempt: int, initial_delay: float | None = None, max_delay: float | None = None) -&gt; float\n</code></pre> <p>Calculate exponential backoff delay with jitter.</p> <p>Prevents thundering herd by adding randomness to retry timing. Jitter helps avoid synchronized retries from multiple clients.</p> Source code in <code>noaa_grib_fetcher.py</code> <pre><code>def calculate_exponential_backoff(\n    attempt: int,\n    initial_delay: float | None = None,\n    max_delay: float | None = None,\n) -&gt; float:\n    \"\"\"\n    Calculate exponential backoff delay with jitter.\n\n    Prevents thundering herd by adding randomness to retry timing.\n    Jitter helps avoid synchronized retries from multiple clients.\n    \"\"\"\n    import random\n\n    if initial_delay is None:\n        initial_delay = settings.retry_settings.initial_delay_seconds\n    if max_delay is None:\n        max_delay = settings.retry_settings.max_delay_seconds\n\n    # Exponential backoff: 2^attempt * initial_delay, capped at max_delay\n    delay = min(initial_delay * (2**attempt), max_delay)\n\n    # Add jitter: \u00b120% of calculated delay to prevent thundering herd\n    jitter_percent = 0.2\n    jitter = delay * jitter_percent * (2 * random.random() - 1)\n    return delay + jitter\n</code></pre>"},{"location":"api/fetcher/#noaa_grib_fetcher.should_retry_status_code","title":"should_retry_status_code","text":"<pre><code>should_retry_status_code(status_code: int) -&gt; bool\n</code></pre> <p>Determine if HTTP status code warrants a retry.</p> <p>Retry strategy: - 404: Don't retry same URL, try next (older) forecast instead - 5xx: Retry (server error, might be transient) - 2xx/3xx: No retry (success) - Other 4xx: No retry (client error, won't be fixed by retrying)</p> <p>Returns True if we should retry the same URL with backoff.</p> Source code in <code>noaa_grib_fetcher.py</code> <pre><code>def should_retry_status_code(status_code: int) -&gt; bool:\n    \"\"\"\n    Determine if HTTP status code warrants a retry.\n\n    Retry strategy:\n    - 404: Don't retry same URL, try next (older) forecast instead\n    - 5xx: Retry (server error, might be transient)\n    - 2xx/3xx: No retry (success)\n    - Other 4xx: No retry (client error, won't be fixed by retrying)\n\n    Returns True if we should retry the same URL with backoff.\n    \"\"\"\n    if status_code == settings.http_settings.not_found:\n        return False  # Move to next (older) forecast instead of retrying\n\n    return status_code &gt;= settings.http_settings.server_error\n</code></pre>"},{"location":"api/query_builder/","title":"Query Builder Reference","text":"<p>Constructs query URLs for NOAA's NOMADS GRIB filter service.</p>"},{"location":"api/query_builder/#data-models","title":"Data Models","text":""},{"location":"api/query_builder/#noaa_query_builder.ModelData","title":"ModelData","text":"<p>               Bases: <code>BaseModel</code></p> <p>Available variables and levels for a model.</p> <p>Defines the complete set of options that can be selected via masks.</p>"},{"location":"api/query_builder/#noaa_query_builder.QueryModel","title":"QueryModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Product-specific query configuration.</p> <p>Defines NOAA URL patterns and file naming for a specific product (e.g., gfs_quarter_degree).</p>"},{"location":"api/query_builder/#noaa_query_builder.QueryMask","title":"QueryMask","text":"<p>               Bases: <code>BaseModel</code></p> <p>Hexadecimal bitmasks for selecting variables and levels.</p> <p>Efficient encoding of which items to include in the query.</p>"},{"location":"api/query_builder/#noaa_query_builder.QueryTime","title":"QueryTime","text":"<p>               Bases: <code>BaseModel</code></p> <p>Forecast run timestamp for NOAA GFS data.</p>"},{"location":"api/query_builder/#noaa_query_builder.SelectedKeys","title":"SelectedKeys","text":"<p>               Bases: <code>BaseModel</code></p> <p>Selected keys decoded from hexadecimal mask.</p> <p>Contains all available keys, the hex mask, and URL prefix for encoding.</p>"},{"location":"api/query_builder/#noaa_query_builder.BoundingBox","title":"BoundingBox","text":"<p>               Bases: <code>BaseModel</code></p> <p>Geographic bounding box for data request.</p> <p>Coordinates in degrees, following NOAA API conventions.</p>"},{"location":"api/query_builder/#noaa_query_builder.CoreSettings","title":"CoreSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Core application settings from configuration.</p> <p>Loaded from settings.toml via dynaconf.</p>"},{"location":"api/query_builder/#noaa_query_builder.LocationSettings","title":"LocationSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Location specified as center point + expanse.</p> <p>More intuitive than bounding box for user input. Converted to BoundingBox internally.</p>"},{"location":"api/query_builder/#noaa_query_builder.QueryStructure","title":"QueryStructure","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete query configuration for NOAA API.</p> <p>Combines all parameters needed to generate query URLs.</p>"},{"location":"api/query_builder/#main-functions","title":"Main Functions","text":""},{"location":"api/query_builder/#noaa_query_builder.generate_query_urls","title":"generate_query_urls","text":"<pre><code>generate_query_urls(qt_batch: tuple[QueryTime, ...], qs: QueryStructure) -&gt; Generator[str, None, None]\n</code></pre> <p>Generate query URLs in order from most to least recent.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def generate_query_urls(\n    qt_batch: tuple[QueryTime, ...],\n    qs: QueryStructure,\n) -&gt; Generator[str, None, None]:\n    \"\"\"Generate query URLs in order from most to least recent.\"\"\"\n\n    for qt in qt_batch:\n        qa = collect_query_arguments(qs=qs)\n        yield build_query_url(qt=qt, qa=qa, qs=qs)\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.build_query_url","title":"build_query_url","text":"<pre><code>build_query_url(qt: QueryTime, qa: tuple[str, str, str], qs: QueryStructure) -&gt; str\n</code></pre> <p>Construct complete NOAA query URL from components.</p> <p>Combines base URI, file/dir parameters, and query arguments (variables, levels, subregion).</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def build_query_url(qt: QueryTime, qa: tuple[str, str, str], qs: QueryStructure) -&gt; str:\n    \"\"\"\n    Construct complete NOAA query URL from components.\n\n    Combines base URI, file/dir parameters, and query arguments\n    (variables, levels, subregion).\n    \"\"\"\n    uri = qs.settings.grib_url.format(\n        filter=qs.query_model.filter,\n    )\n    core = urlencode(\n        (\n            (\n                \"dir\",\n                qs.query_model.dir.format(**qt.model_dump()),\n            ),\n            (\n                \"file\",\n                qs.query_model.file.format(**qt.model_dump()),\n            ),\n        )\n    )\n    query_string = \"&amp;\".join([core, *qa])\n    return f\"{uri}?{query_string}\"\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.collect_query_arguments","title":"collect_query_arguments","text":"<pre><code>collect_query_arguments(qs: QueryStructure) -&gt; tuple[str, str, str]\n</code></pre> <p>Build URL query arguments from query structure.</p> <p>Returns tuple of: (variables_string, levels_string, subregion_string) All encoded for URL inclusion.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def collect_query_arguments(qs: QueryStructure) -&gt; tuple[str, str, str]:\n    \"\"\"\n    Build URL query arguments from query structure.\n\n    Returns tuple of: (variables_string, levels_string, subregion_string)\n    All encoded for URL inclusion.\n    \"\"\"\n    variables = get_url_encoded_keys(**qs.variables.model_dump())\n    levels = get_url_encoded_keys(**qs.levels.model_dump())\n    subregion = \"=\".join([\"subregion\", urlencode(query=qs.bounding_box.model_dump())])\n\n    return variables, levels, subregion\n</code></pre>"},{"location":"api/query_builder/#geographic-calculations","title":"Geographic Calculations","text":""},{"location":"api/query_builder/#noaa_query_builder.create_bounding_box","title":"create_bounding_box","text":"<pre><code>create_bounding_box(ls: LocationSettings) -&gt; BoundingBox\n</code></pre> <p>Create geographic bounding box centered on given coordinates.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def create_bounding_box(ls: LocationSettings) -&gt; BoundingBox:\n    \"\"\"Create geographic bounding box centered on given coordinates.\"\"\"\n\n    lat_min, lat_max = calculate_latitude_bounds(ls.center_lat, ls.height_degrees)\n    lon_min, lon_max = calculate_longitude_bounds(ls.center_lon, ls.width_degrees)\n\n    return BoundingBox(\n        toplat=lat_max,\n        leftlon=lon_min,\n        rightlon=lon_max,\n        bottomlat=lat_min,\n    )\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.calculate_latitude_bounds","title":"calculate_latitude_bounds","text":"<pre><code>calculate_latitude_bounds(center_lat: float, height_degrees: float) -&gt; tuple[float, float]\n</code></pre> <p>Calculate min/max latitude from center point and height.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def calculate_latitude_bounds(\n    center_lat: float,\n    height_degrees: float,\n) -&gt; tuple[float, float]:\n    \"\"\"Calculate min/max latitude from center point and height.\"\"\"\n\n    half_height = height_degrees / 2\n    min_lat = clamp_latitude(center_lat - half_height)\n    max_lat = clamp_latitude(center_lat + half_height)\n    return min_lat, max_lat\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.calculate_longitude_bounds","title":"calculate_longitude_bounds","text":"<pre><code>calculate_longitude_bounds(center_lon: float, width_degrees: float) -&gt; tuple[float, float]\n</code></pre> <p>Calculate min/max longitude from center point and width.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def calculate_longitude_bounds(\n    center_lon: float,\n    width_degrees: float,\n) -&gt; tuple[float, float]:\n    \"\"\"Calculate min/max longitude from center point and width.\"\"\"\n\n    normalized_longitude = normalize_longitude(center_lon)\n    half_width = width_degrees / 2\n    min_lon = normalize_longitude(normalized_longitude - half_width)\n    max_lon = normalize_longitude(normalized_longitude + half_width)\n    return min_lon, max_lon\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.clamp_latitude","title":"clamp_latitude","text":"<pre><code>clamp_latitude(latitude: float) -&gt; float\n</code></pre> <p>Constrain latitude to valid range [-90, 90].</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def clamp_latitude(latitude: float) -&gt; float:\n    \"\"\"Constrain latitude to valid range [-90, 90].\"\"\"\n\n    return max(-90.0, min(90.0, latitude))\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.normalize_longitude","title":"normalize_longitude","text":"<pre><code>normalize_longitude(longitude: float) -&gt; float\n</code></pre> <p>Normalize longitude to [0, 360) range.</p> <p>NOAA API expects 0-360 format, not -180 to 180.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def normalize_longitude(longitude: float) -&gt; float:\n    \"\"\"\n    Normalize longitude to [0, 360) range.\n\n    NOAA API expects 0-360 format, not -180 to 180.\n    \"\"\"\n    normalized = longitude % 360\n    return normalized if normalized &gt;= 0 else normalized + 360\n</code></pre>"},{"location":"api/query_builder/#time-calculations","title":"Time Calculations","text":""},{"location":"api/query_builder/#noaa_query_builder.build_qt","title":"build_qt","text":"<pre><code>build_qt(dt_object: datetime, qs: QueryStructure) -&gt; QueryTime\n</code></pre> <p>Convert datetime to NOAA query time format.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def build_qt(dt_object: datetime, qs: QueryStructure) -&gt; QueryTime:\n    \"\"\"Convert datetime to NOAA query time format.\"\"\"\n    return QueryTime(\n        date_utc=format_date_utc(dt_object=dt_object),\n        cycle_hour_utc=f\"{get_latest_run_start(dt_object=dt_object, qs=qs).hour:02}\",\n    )\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.generate_qt_batch","title":"generate_qt_batch","text":"<pre><code>generate_qt_batch(reference_time: datetime, qs: QueryStructure) -&gt; tuple[QueryTime, ...]\n</code></pre> <p>Generate batch of query times to try, from most to least recent.</p> <p>Most recent forecasts are often not yet available on NOAA servers (processing delay). This generates fallback times going back max_lookback_hours in forecast_interval_hours increments.</p> <p>Special logic: if latest run started less than 3 hours ago, skip it since NOAA processing typically takes 3+ hours.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def generate_qt_batch(\n    reference_time: datetime,\n    qs: QueryStructure,\n) -&gt; tuple[QueryTime, ...]:\n    \"\"\"\n    Generate batch of query times to try, from most to least recent.\n\n    Most recent forecasts are often not yet available on NOAA servers\n    (processing delay). This generates fallback times going back\n    max_lookback_hours in forecast_interval_hours increments.\n\n    Special logic: if latest run started less than 3 hours ago, skip it\n    since NOAA processing typically takes 3+ hours.\n    \"\"\"\n    cropped_time = crop_to_hour(reference_time)\n    latest_run_start = get_latest_run_start(cropped_time, qs)\n\n    # Skip very recent run if it started less than 3 hours ago\n    if latest_run_start + timedelta(hours=3) &lt;= datetime.now(tz=timezone.utc):\n        latest_cycle = cropped_time.replace(hour=latest_run_start.hour)\n    else:\n        # Too recent, try previous cycle\n        latest_cycle = cropped_time.replace(\n            hour=(latest_run_start - timedelta(hours=6)).hour,\n        )\n\n    return tuple(\n        build_qt(dt_object=latest_cycle - timedelta(hours=offset), qs=qs)\n        for offset in range(\n            0,\n            qs.settings.max_lookback_hours + 1,\n            qs.settings.forecast_interval_hours,\n        )\n    )\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.get_latest_run_start","title":"get_latest_run_start","text":"<pre><code>get_latest_run_start(dt_object: datetime, qs: QueryStructure) -&gt; datetime\n</code></pre> <p>Round down to nearest forecast cycle.</p> <p>For GFS: runs at 00, 06, 12, 18 UTC (every 6 hours). Interval configured in settings.forecast_interval_hours.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def get_latest_run_start(dt_object: datetime, qs: QueryStructure) -&gt; datetime:\n    \"\"\"\n    Round down to nearest forecast cycle.\n\n    For GFS: runs at 00, 06, 12, 18 UTC (every 6 hours).\n    Interval configured in settings.forecast_interval_hours.\n    \"\"\"\n    process_start_hour = get_latest_of_multiple(hour=dt_object.hour, qs=qs)\n    return crop_to_hour(dt_object).replace(hour=process_start_hour)\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.get_latest_of_multiple","title":"get_latest_of_multiple","text":"<pre><code>get_latest_of_multiple(hour: int, qs: QueryStructure) -&gt; int\n</code></pre> <p>Round hour down to nearest forecast interval.</p> <p>E.g., if forecast_interval_hours is 6: 14 -&gt; 12, 23 -&gt; 18</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def get_latest_of_multiple(hour: int, qs: QueryStructure) -&gt; int:\n    \"\"\"\n    Round hour down to nearest forecast interval.\n\n    E.g., if forecast_interval_hours is 6: 14 -&gt; 12, 23 -&gt; 18\n    \"\"\"\n    hour_interval = qs.settings.forecast_interval_hours\n    return (hour // hour_interval) * hour_interval\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.crop_to_hour","title":"crop_to_hour","text":"<pre><code>crop_to_hour(dt_object: datetime) -&gt; datetime\n</code></pre> <p>Round down to nearest hour.</p> <p>Removes minutes, seconds, microseconds for forecast time calculations.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def crop_to_hour(dt_object: datetime) -&gt; datetime:\n    \"\"\"\n    Round down to nearest hour.\n\n    Removes minutes, seconds, microseconds for forecast time calculations.\n    \"\"\"\n    return dt_object.replace(\n        minute=0,\n        second=0,\n        microsecond=0,\n    )\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.format_date_utc","title":"format_date_utc","text":"<pre><code>format_date_utc(dt_object: datetime) -&gt; str\n</code></pre> <p>Format datetime as YYYYMMDD for NOAA query.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def format_date_utc(dt_object: datetime) -&gt; str:\n    \"\"\"Format datetime as YYYYMMDD for NOAA query.\"\"\"\n\n    return dt_object.strftime(\"%Y%m%d\")\n</code></pre>"},{"location":"api/query_builder/#mask-operations","title":"Mask Operations","text":""},{"location":"api/query_builder/#noaa_query_builder.get_binary_mask_from_hex","title":"get_binary_mask_from_hex","text":"<pre><code>get_binary_mask_from_hex(hex_mask: str, mask_length: int) -&gt; tuple[int, ...]\n</code></pre> <p>Convert hexadecimal mask string to tuple of binary integers.</p> <p>E.g., \"0xF\" with length 4 -&gt; (1, 1, 1, 1)</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def get_binary_mask_from_hex(hex_mask: str, mask_length: int) -&gt; tuple[int, ...]:\n    \"\"\"\n    Convert hexadecimal mask string to tuple of binary integers.\n\n    E.g., \"0xF\" with length 4 -&gt; (1, 1, 1, 1)\n    \"\"\"\n    binary_string = format(int(hex_mask, base=16), \"b\").rjust(mask_length, \"0\")\n    return tuple(int(value) for value in binary_string)\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.get_url_encoded_keys","title":"get_url_encoded_keys","text":"<pre><code>get_url_encoded_keys(all_keys: list[str], hex_mask: str, prefix: str) -&gt; str\n</code></pre> <p>Convert hexadecimal mask to URL-encoded query string.</p> <p>Only includes keys where mask bit is 1. Adds prefix to each key. E.g., [\"TMP\", \"UGRD\"] with mask 0x3 and prefix \"var_\" -&gt; \"var_TMP=on&amp;var_UGRD=on\"</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def get_url_encoded_keys(all_keys: list[str], hex_mask: str, prefix: str) -&gt; str:\n    \"\"\"\n    Convert hexadecimal mask to URL-encoded query string.\n\n    Only includes keys where mask bit is 1. Adds prefix to each key.\n    E.g., [\"TMP\", \"UGRD\"] with mask 0x3 and prefix \"var_\" -&gt;\n    \"var_TMP=on&amp;var_UGRD=on\"\n    \"\"\"\n    binary_mask = get_binary_mask_from_hex(hex_mask=hex_mask, mask_length=len(all_keys))\n    return urlencode(\n        [(f\"{prefix}{key}\", \"on\") for key, mask in zip(all_keys, binary_mask) if mask]\n    )\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.build_new_mask","title":"build_new_mask","text":"<pre><code>build_new_mask(all_values: list[str], selected_values: tuple[str, ...]) -&gt; str\n</code></pre> <p>Build hexadecimal mask from selected values.</p> <p>Inverse of reveal_masked_values. Creates mask where bit is 1 if value is selected.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def build_new_mask(all_values: list[str], selected_values: tuple[str, ...]) -&gt; str:\n    \"\"\"\n    Build hexadecimal mask from selected values.\n\n    Inverse of reveal_masked_values. Creates mask where bit is 1\n    if value is selected.\n    \"\"\"\n    raw_mask = [\"1\" if key in selected_values else \"0\" for key in all_values]\n    return hex(int(\"\".join(raw_mask), 2))\n</code></pre>"},{"location":"api/query_builder/#noaa_query_builder.reveal_masked_values","title":"reveal_masked_values","text":"<pre><code>reveal_masked_values(all_values: list[str], hex_mask: str) -&gt; list[str]\n</code></pre> <p>Decode hexadecimal mask to list of selected values.</p> <p>Returns only values where mask bit is 1.</p> Source code in <code>noaa_query_builder.py</code> <pre><code>def reveal_masked_values(all_values: list[str], hex_mask: str) -&gt; list[str]:\n    \"\"\"\n    Decode hexadecimal mask to list of selected values.\n\n    Returns only values where mask bit is 1.\n    \"\"\"\n    binary_mask = get_binary_mask_from_hex(\n        hex_mask=hex_mask, mask_length=len(all_values)\n    )\n    return [key for key, mask in zip(all_values, binary_mask) if mask]\n</code></pre>"}]}